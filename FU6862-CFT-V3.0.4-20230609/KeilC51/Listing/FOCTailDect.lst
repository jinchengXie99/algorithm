C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE FOCTAILDECT
OBJECT MODULE PLACED IN .\Output\FOCTailDect.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\User\Source\Function\FOCTailDect.c LARGE OMF2 WARNINGLEVEL(0) OPTIMIZ
                    -E(9,SPEED) BROWSE INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\FOCTailDect.lst) TABS(
                    -2) OBJECT(.\Output\FOCTailDect.obj)

line level    source

   1          /*  -------------------------- (C) COPYRIGHT 2022 Fortiortech ShenZhen ---------------------------*/
   2          /**
   3           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   4           * @file      xxx.c
   5           * @author    Fortiortech  Appliction Team
   6           * @since     Create:2022-07-14
   7           * @date      Last modify:2022-07-14
   8           * @note      Last modify author is Leo.li
   9           * @brief      
  10           */
  11          
  12          
  13          /* Includes -------------------------------------------------------------------------------------*/
  14          // #include <FOCTailDect.h>
  15          #include <FU68xx_2.h>
  16          #include <Myproject.h>
  17          
  18          #if ((FRDetectMethod == FOCMethod) && (TailWind_Mode == TailWind))
              MotorTailWindTypeDef xdata  TailWindDetect;
              
              /** 
               * @brief      é¡ºé€†é£å‚æ•°åˆå§‹åŒ–
               * @date       2022-07-14
               */ 
              void TailWindDetectInit(void)
              {
                  TailWindDetect.MotorTailWindState     = NormalTailWind;                     //  åˆå§‹çŠ¶æ€ä¸ºæ­£å¸¸ç
             -š„é¡ºé€†é£çŠ¶æ€
                  TailWindDetect.TempThailWindSpeedBase = ThailWindSpeedBase;                 //  é¡ºé€†é£è®¡ç®—çš„spee
             -dbase
                  FOC_Init();                                                                 // FOCçš„åˆå§‹åŒ–
                  FOC_DQKP    = DQKP_TailWind;                                                // é¡ºé€†é£çš„ç”µæµç¯KP
                  FOC_DQKI    = DQKI_TailWind;                                                // é¡ºé€†é£çš„ç”µæµç¯KI
                  FOC_EKP     = OBSW_KP_GAIN_WIND;                                            // é¡ºé€†é£é€Ÿåº¦ä¼°ç®—çš
             -„KP
                  FOC_EKI     = OBSW_KI_GAIN_WIND;                                            // é¡ºé€†é£é€Ÿåº¦ä¼°ç®—çš
             -„KI
                  FOC_OMEKLPF = SPEED_KLPF_WIND;                                              // é¡ºé€†é£ä¸‹çš„é€Ÿåº¦æ»
             -¤æ³¢ç³»æ•°
                  SetBit(FOC_CR1, ANGM);                                                      // ä¼°ç®—æ¨¡å¼           
             -                                      // Driver è¾“å‡ºè®¡æ•°å™¨ä½¿èƒ½ï¼Œ0-ç¦æ­¢ï¼Œ1-ä½¿èƒ½
                  DRV_CMR    |= 0x3F;                                                          // Uã€Vã€Wç›¸è¾“å‡º
                  MOE         = 1;                                                              // æ‰“å¼€MOE
                  FOC_IDREF   = 0;                                                              // Dè½´ç»™å®šç”µæµ
                  FOC_IQREF   = 0;
              }
              
              /** 
               * @brief      é¡ºé€†é£é€Ÿåº¦æ£€æµ‹ï¼Œæ ¹æ®è§’åº¦çš„å˜åŒ–è¶‹åŠ¿æ¥åˆ¤æ–­æ–¹å‘
               * @date       2022-07-14
               */
              void TailWindSpeedDetect(void)
              {
C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 2   

                  static int16 LatestTheta;
                  
                  if (mcState == mcTailWind)
                  {
                      //é¡ºé£æ£€æµ‹è¿‡ç¨‹ç”±äºFOCå†…éƒ¨æ ¹æ®ç”µæµä¼°ç®—è§’åº¦ï¼Œæ•…ç›´æ¥å¯¹FOC_ETHETAè¿›è¡Œå¤„ç†
                      if (TailWindDetect.MotorTailWindState == NormalTailWind)
                      {
                          LatestTheta = FOC__ETHETA;
                          
                          //æ—‹è½¬æ–¹å‘åˆ¤æ–­åœ¨ <-170åº¦   <10 >-10  >170åº¦ä¸‰ä¸ªçŠ¶æ€åˆ‡æ¢çš„æ—¶é—´
                          if (LatestTheta < -30946)
                          {
                              //è®¡æ•°å™¨æœªæ¸…é›¶æˆ–ä»çŠ¶æ€3è·³åˆ°çŠ¶æ€1æ—¶æ¸…é›¶
                              if ((TailWindDetect.SpeedTimerClearStatus == 0) || (TailWindDetect.AngleState == 3))
                              {
                                  TailWindDetect.SpeedCountTimer       = 0;
                                  TailWindDetect.SpeedTimerClearStatus = 1;
                                  
                                  if (TailWindDetect.AngleState == 3)
                                  {
                                      TailWindDetect.ShakeTimes++;    //æ¥å›1å’Œ3ä¹‹é—´æŠ–åŠ¨ï¼ŒæŠ–åŠ¨æ¬¡æ•°åŠ 1
                                  }
                              }
                              
                              //<-170åº¦  æ—¶è®¾ç½®çŠ¶æ€ä¸º1ï¼Œå¹¶æ¸…é›¶SpeedCountTimeråœ¨TIM5ä¸­è®¡æ—¶
                              TailWindDetect.AngleState = 1;
                          }
                          else if ((LatestTheta > -1820) && (LatestTheta < 1820)) //<10 >-10
                          {
                              //çŠ¶æ€1æˆ–çŠ¶æ€3åˆ‡æ¢åˆ°çŠ¶æ€2æ—¶ä¿å­˜å½“å‰è½¬é€Ÿæ—¶é—´è‡³TailWindDetect.SpeedCount
             -[SpeedStoreNum]
                              if ((TailWindDetect.AngleState == 1) || (TailWindDetect.AngleState == 3))
                              {
                                  //è®¡ç®—å½“å‰è½¬é€Ÿï¼ŒRPM
                                  TailWindDetect.SpeedCountTimer += 1;//é˜²æ­¢ä¸º0
                                  TailWindDetect.TailWindSpeed   = DivQ_L_MDU(TailWindDetect.TempThailWindSpeedBase >>16
             -, TailWindDetect.TempThailWindSpeedBase, TailWindDetect.SpeedCountTimer);//æµ‹å‡ºé€Ÿåº¦
                                  TailWindDetect.SpeedStoreNum++;
                                  
                                  //ç”¨äºSpeedCountTimeræ¸…é›¶
                                  if (TailWindDetect.SpeedTimerClearStatus == 1)
                                  {
                                      TailWindDetect.SpeedTimerClearStatus = 0;
                                  }
                                  
                                  //æœ‰1çŠ¶æ€åˆ‡æ¢åˆ°2çŠ¶æ€è¯´æ˜è§’åº¦é€’å¢æ—‹è½¬æ–¹å‘ä¸ºCWï¼Œ3->2åˆ™ä¸ºCCW
                                  if (TailWindDetect.AngleState == 1)
                                  {
                                      TailWindDetect.MotorDir = CW;
                                  }
                                  else if (TailWindDetect.AngleState == 3)
                                  {
                                      TailWindDetect.MotorDir = CCW;
                                  }
                                  
                                  TailWindDetect.ShakeTimes = 0;//æ¸…é™¤æ¥å›æŠ–åŠ¨çš„è®¡æ•°
                              }
                              
                              TailWindDetect.AngleState = 2;
                          }
                          //>170åº¦æ—¶
                          else if (LatestTheta > 30946)
C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 3   

                          {
                              //è®¡æ•°å™¨æœªæ¸…é›¶æˆ–ä»çŠ¶æ€1è·³åˆ°çŠ¶æ€3æ—¶æ¸…é›¶
                              if ((TailWindDetect.SpeedTimerClearStatus == 0) || (TailWindDetect.AngleState == 1))
                              {
                                  TailWindDetect.SpeedCountTimer       = 0;
                                  TailWindDetect.SpeedTimerClearStatus = 1;
                                  
                                  if (TailWindDetect.AngleState == 1)
                                  {
                                      TailWindDetect.ShakeTimes++;    //æ¥å›1å’Œ3ä¹‹é—´æŠ–åŠ¨
                                  }
                              }
                              
                              TailWindDetect.AngleState = 3;
                          }
                      }
                  }
              }
              
              /** 
               * @brief      é¡ºé£å¯åŠ¨
               * @date       2022-07-14
               */
              void FOCCloseLoopStart(void)
              {
                  //é…ç½®å¯åŠ¨çš„å‚æ•°ï¼ŒOmegaæ¨¡å¼
                  FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
                  FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
                  FOC_EFREQHOLD = Motor_Omega_Ramp_End;
                  SetBit(FOC_CR1, EFAE);                                                      // ä¼°ç®—å™¨å¼ºåˆ¶è¾“å‡º
                  ClrBit(FOC_CR1, RFAE);                                                      // ç¦æ­¢å¼ºæ‹‰
                  SetBit(FOC_CR1, ANGM);                                                      // ä¼°ç®—æ¨¡å¼
                  //ç”µæµç¯çš„PIå’Œè¾“å‡ºé™èµ‹å€¼
                  FOC_DQKP = DQKP;
                  FOC_DQKI = DQKI;
                  FOC_DMAX = DOUTMAX;
                  FOC_DMIN = DOUTMIN;
                  FOC_QMAX = QOUTMAX;
                  FOC_QMIN = QOUTMIN;
                
                  /*********PLLæˆ–SMO/AO**********/
                  //æ ¹æ®ä¸åŒè½¬é€Ÿç¡®å¯åŠ¨çš„ATO_BWå€¼   
                  #if (EstimateAlgorithm == PLL)
                  mcFocCtrl.mcIqref = IQ_RUN_CURRENT;
                #else
                  //æ ¹æ®ä¸åŒè½¬é€Ÿç¡®å¯åŠ¨çš„ATO_BWå€¼
                  if (TailWindDetect.TailWindSpeed > 16383)
                  {
                      FOC_EKP               = OBSW_KP_GAIN_RUN1;
                      FOC_EKI               = OBSW_KI_GAIN_RUN1;
                      mcFocCtrl.mcIqref     = IQ_RUN_CURRENT;
                      mcFocCtrl.State_Count = 10;
                  }
                  else if (TailWindDetect.TailWindSpeed > 5000)
                  {
                      FOC_EKP               = OBSW_KP_GAIN_RUN2;
                      FOC_EKI               = OBSW_KI_GAIN_RUN2;
                      mcFocCtrl.mcIqref     = IQ_RUN_CURRENT;
                      mcFocCtrl.State_Count = 60;
                  }
                  else
                  {
C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 4   

                      FOC_EKP               = OBSW_KP_GAIN_RUN;
                      FOC_EKI               = OBSW_KI_GAIN_RUN;
                      mcFocCtrl.mcIqref     = IQ_RUN_CURRENT;
                      mcFocCtrl.State_Count = 120;
                  } 
                  #endif 
                  /*estimate parameter set*/
                  FOC_OMEKLPF = SPEED_KLPF;
                  FOC_IDREF   = ID_RUN_CURRENT;             // Dè½´å¯åŠ¨ç”µæµ
                  FOC_IQREF   = mcFocCtrl.mcIqref ;         // Qè½´å¯åŠ¨ç”µæµ
                  PI_UK       =   mcFocCtrl.mcIqref;
                  mcState            = mcRun;
                  mcFocCtrl.CtrlMode = 0;
              }
              
              
              /** 
               * @brief      FOCé¡ºé€†é£æ£€æµ‹çš„æ—¶é—´å¤„ç†
               * @date       2022-07-14
               */
              void FOCTailWindTimeLimit(void)
              {
                  if (mcState == mcTailWind)
                  {
                      //1Hz Min
                      if (TailWindDetect.SpeedCountTimer < TailWind_Time)                     // SpeedCountTimer-è®¡ç®—æ
             -—¶é—´é—´éš”
                      {
                          TailWindDetect.SpeedCountTimer++;
                      }
                      else
                      {
                          TailWindDetect.TailWindSpeed       = 0;                             //é€Ÿåº¦ä¸º0
                          TailWindDetect.SpeedCountTimer     = 0;
                          TailWindDetect.SpeedOverFlowStatus = 1;                             // è½¬é€Ÿè®¡æ•°æº¢å‡ºæ ‡å¿
             -—
                      }
                  }
              }
              
              
              /** 
               * @brief      é¡ºé£é€†é£å‚æ•°é…ç½®å‡½æ•°
               * @date       2022-07-14
               */
              void FOCTailWindDealwith(void)
              {
                  /*********SMO/AO**********/
                  #if ((EstimateAlgorithm == SMO)||(EstimateAlgorithm == AO))
                  SMO_TailWindDealwith();
                  #endif //end    EstimateAlgorithm
              }
              
              void SMO_TailWindDealwith(void)
              {
                  //ç”µæœºçŠ¶æ€ä¸ºæ­£è½¬ä¸”è½¬é€Ÿè®¡æ•°æº¢å‡ºæ—¶ï¼›æˆ–1-3çŠ¶æ€æŠ–åŠ¨æ¬¡æ•°å¤§äº2æ¬¡æ—¶ï¼Œè®¤ä¸ºé™æ­¢
                  if (((TailWindDetect.MotorDir == CW) && (TailWindDetect.SpeedOverFlowStatus)) || (TailWindDetect.Shake
             -Times > 2))
                  {
                      MOE = 0;
                      SetBit(DRV_CR, FOCEN);   //å…³é—­FOC
                      mcState                           = mcPosiCheck;
C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 5   

                      McStaSet.SetFlag.PosiCheckSetFlag = 0;
                      mcFocCtrl.mcPosCheckAngle         = 0xffff;         // è§’åº¦èµ‹åˆå€¼
                  }
                  else if ((TailWindDetect.MotorDir == CCW) && (TailWindDetect.SpeedStoreNum > 2)) //||((TailWindDetect.
             -MotorDir == CW)&&(TailWindDetect.TailWindSpeed>TailWindStartMinSpeed)))
                  {
                      if (TailWindDetect.TailWindSpeed < 13000)
                      {
                          mcFocCtrl.mcIqref       = IQ_Start_CURRENT + I_Value(0.2);       // Qè½´å¯åŠ¨ç”µæµ
                          TailWindDetect.AntiFlag = 1;
                      }
                      else if (TailWindDetect.TailWindSpeed < 8000)
                      {
                          mcFocCtrl.mcIqref       = IQ_Start_CURRENT + I_Value(0.3);       // Qè½´å¯åŠ¨ç”µæµ
                          TailWindDetect.AntiFlag = 2;
                      }
                      else if (TailWindDetect.TailWindSpeed < 3000)
                      {
                          mcFocCtrl.mcIqref       = IQ_Start_CURRENT + I_Value(0.4);       // Qè½´å¯åŠ¨ç”µæµ
                          TailWindDetect.AntiFlag = 3;
                      }
                      else
                      {
                          mcFocCtrl.mcIqref       = IQ_Start_CURRENT + I_Value(0.5);       // Qè½´å¯åŠ¨ç”µæµ
                          TailWindDetect.AntiFlag = 4;
                      }
                      
                      FOC_DQKP              = DQKP;
                      FOC_DQKI              = DQKI;
                      FOC_DMAX              = DOUTMAX;
                      FOC_DMIN              = DOUTMIN;
                      FOC_QMAX              = QOUTMAX;
                      FOC_QMIN              = QOUTMIN;
                      FOC_EK2               = OBS_K2T;
                      FOC_IQREF             = mcFocCtrl.mcIqref;
                      mcFocCtrl.State_Count = 120;
                      FOC_EKP               = OBSW_KP_GAIN;
                      FOC_EKI               = OBSW_KI_GAIN;
                      FOC_IDREF             = 0;
                      mcState               = mcRun;
                      mcFocCtrl.CtrlMode    = 0;
                  }
                  else if (TailWindDetect.MotorDir == CW)
                  {
                      //è¶…è¿‡æ£€æµ‹æ¬¡æ•°TailWindDetect.SpeedStoreNumåˆ‡è½¬é€ŸTailWindStartMinSpeedä»¥ä¸Šæ—¶ç›´æ¥é¡ºé£
             -å¯åŠ¨
                      if ((TailWindDetect.TailWindSpeed > TailWindStartMinSpeed) && (TailWindDetect.SpeedStoreNum >= 2))
                      {
                          FOCCloseLoopStart();
                      }
                  }
              }
              
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.7.0   FOCTAILDECT                                                       08/30/2023 13:47:06 PAGE 6   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
