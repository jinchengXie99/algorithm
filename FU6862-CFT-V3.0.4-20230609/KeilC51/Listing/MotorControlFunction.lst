C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MOTORCONTROLFUNCTION
OBJECT MODULE PLACED IN .\Output\MotorControlFunction.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\User\Source\Function\MotorControlFunction.c LARGE OMF2 WARNINGLEVEL(0
                    -) OPTIMIZE(9,SPEED) BROWSE INCDIR(..\User\Include;..\FU68xx_Hardware_Driver\Include) DEBUG PRINT(.\Listing\MotorControlF
                    -unction.lst) TABS(2) OBJECT(.\Output\MotorControlFunction.obj)

line level    source

   1          /*  -------------------------- (C) COPYRIGHT 2022 Fortiortech ShenZhen ---------------------------*/
   2          /**
   3           * @copyright (C) COPYRIGHT 2022 Fortiortech Shenzhen
   4           * @file      xxx.c
   5           * @author    Fortiortech  Appliction Team
   6           * @since     Create:2022-07-14
   7           * @date      Last modify:2022-07-14
   8           * @note      Last modify author is Leo.li
   9           * @brief      
  10           */
  11          
  12          
  13          /* Includes -------------------------------------------------------------------------------------*/
  14          #include <FU68xx_2.h>
  15          #include <Myproject.h>
  16          #include <FU68xx_2_DMA.h>
  17          CurrentOffset xdata mcCurOffset;
  18          
  19          /** 
  20           * @brief      å¯¹FOCçš„ç›¸å…³å¯„å­˜å™¨è¿›è¡Œé…ç½®,å…ˆæ¸…ç†å¯„å­˜å™¨ï¼Œåé…ç½®ï¼Œæœ€åä½¿èƒ½
  21           * @exception  åˆå§‹åŒ–FOCï¼Œéœ€è¦å…ˆå…³é—­DRVIVERï¼Œå¯¹FOCå¯„å­˜å™¨é…ç½®å®Œæˆåï¼Œä½¿èƒ½FOCå†æ‰“å¼€
             -DRVIVER,å¦åˆ™å¯èƒ½å¯¼è‡´ç¬¬ä¸€æ‹ç”µæµé‡‡æ ·é”™è¯¯
  22           * @date       2022-07-14
  23           */
  24          void FOC_Init(void)
  25          {
  26   1          /*DRVè®¡æ•°å™¨ä½¿èƒ½ï¼Œ0-ç¦æ­¢ï¼Œ1-ä½¿èƒ½*/
  27   1          ClrBit(DRV_CR, DRVEN);
  28   1          /*ä½¿èƒ½FOC*/
  29   1          ClrBit(DRV_CR, FOCEN);
  30   1          SetBit(DRV_CR, FOCEN);
  31   1          SetBit(FOC_CR3, ESCMS);
  32   1          /*é…ç½®FOCå¯„å­˜å™¨*/
  33   1          FOC_CR1             = 0;                                                                            //
             - æ¸…é›¶ FOC_CR1
  34   1          FOC_CR2             = 0;                                                                            //
             - æ¸…é›¶ FOC_CR2
  35   1          FOC_IDREF       = 0;                                                                            // æ¸…
             -é›¶ Id
  36   1          FOC_IQREF       = 0;                                                                            // æ¸…
             -é›¶ Iq
  37   1          FOC__THETA      = 0;                                                                            // æ¸…
             -é›¶ è§’åº¦
  38   1          FOC_RTHEACC     = 0;                                                                            // æ¸…
             -é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
  39   1          FOC__RTHESTEP   = 0;                                                                        //
  40   1          FOC__RTHECNT    = 0;                                                                            //
  41   1          FOC_THECOMP    = _Q15(10.0 / 180.0);                                            // SMO ä¼°ç®—è¡¥å¿è§’
  42   1          FOC_THECOR         = 0x02;                                                                 // è¯¯å·®è§
             -’åº¦è¡¥å¿
  43   1          /*ç”µæµç¯å‚æ•°é…ç½®*/
  44   1          FOC_DMAX            = DOUTMAX;
  45   1          FOC_DMIN            = DOUTMIN;
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 2   

  46   1          FOC_QMAX            = QOUTMAX;
  47   1          FOC_QMIN            = QOUTMIN;
  48   1          /*ä½ç½®ä¼°ç®—å‚æ•°é…ç½®*/
  49   1          FOC_EK1             = OBS_K1T;
  50   1          FOC_EK2             = OBS_K2T;
  51   1          FOC_EK3             = OBS_K3T;
  52   1          FOC_EK4             = OBS_K4T;
  53   1          FOC_FBASE           = OBS_FBASE;
  54   1          FOC_OMEKLPF         = SPEED_KLPF;
  55   1          FOC_EBMFK           = OBS_KLPF;
  56   1          FOC_TGLI            = PWM_TGLI_LOAD;
  57   1        
  58   1        #if(EstimateAlgorithm == AO)
  59   1          SetBit(FOC_CR3, MFP_EN);
  60   1        #else
                ClrBit(FOC_CR3, MFP_EN);
                #endif
  63   1        
  64   1           /*********PLLæˆ–SMO/AO**********/
  65   1          #if (EstimateAlgorithm == PLL)
                  {
                      SetBit(FOC_CR2, ESEL);
                      FOC_KSLIDE      = OBSE_PLLKP_GAIN;
                      FOC_EKLPFMIN    = OBSE_PLLKI_GAIN;    
                  }
                  #else
  72   1          {
  73   2              ClrBit(FOC_CR2, ESEL);
  74   2              FOC_KSLIDE    = OBS_KSLIDE;
  75   2              FOC_EKLPFMIN    = OBS_EA_KS;
  76   2          }
  77   1          #endif //end SVPMW_Mode
  78   1          SetBit(FOC_CR1, SVPWMEN);                                                           // SVPWMæ¨¡å¼
  79   1          
  80   1          //  /*æ­£åè½¬*/
  81   1          if (MCCtrl.FR_Status == 1)
  82   1          {
  83   2              SetBit(DRV_CR, DDIR);                              // åè½¬æ ‡å¿—ä½
  84   2          }
  85   1          else
  86   1          {
  87   2              ClrBit(DRV_CR, DDIR);
  88   2          }
  89   1          
  90   1          /**è¿‡è°ƒåˆ¶**/
  91   1          #if (OverModulation)
                  {
                      SetBit(FOC_CR1, OVMDL);                                                 // è¿‡è°ƒåˆ¶
                  }
                  #endif //end OverModulation
  96   1          /*å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼*/
  97   1          #if (Shunt_Resistor_Mode == Single_Resistor)
  98   1          {
  99   2              SetReg(FOC_CR1, CSM0 | CSM1, 0x00);
 100   2              FOC_TSMIN = PWM_TS_LOAD;                                                          // æœ€å°é‡‡æ ·ç
             -ª—å£
 101   2              FOC_TRGDLY = 0x0F;                                                                // é‡‡æ ·æ—¶åˆ»å
             -œ¨ä¸­ç‚¹ï¼Œä¸€èˆ¬è€ƒè™‘å¼€å…³å™ªå£°å½±å“ï¼Œä¼šè®¾ç½®å»¶è¿Ÿï¼›
 102   2              // 0x0cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
 103   2              ClrBit(FOC_CR2, F5SEG);                                                           // 7æ®µå¼
 104   2              SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
 105   2          }
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 3   

 106   1          /*åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81*/
 107   1          #elif (Shunt_Resistor_Mode == Double_Resistor)                  // double resistor sample
                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, CSM0);
                      FOC_TSMIN = PWM_DT_LOAD;                                                            // æ­»åŒºè¡¥å
             -¿å€¼
                      FOC_TRGDLY = 0x06;                                                                    // ADCé‡‡æ ·
             -çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
                      // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                      FOC_TBLO = PWM_DLOWL_TIME;                            //ä¸‹æ¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
                      /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                      #if (SVPMW_Mode == SVPWM_7_Segment)
                      {
                          ClrBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
                      }
                      #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
                      }
                      #endif
                      #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                      {
                          ClrBit(FOC_CR2, DSS);                                                             // 7æ®µå¼
                      }
                      #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, FOC_DSS);                                                       // 7æ®µå¼
                      }
                      #endif //end DouRes_Sample_Mode
                  }
                  /*ä¸‰ç”µé˜»é‡‡æ ·*/
                  #elif (Shunt_Resistor_Mode == Three_Resistor)                     // signel resistor sample
                  {
                      SetReg(FOC_CR1, CSM0 | CSM1, CSM0 | CSM1);// ä¸‰ç”µé˜»
                      FOC_TSMIN  = PWM_DT_LOAD;                                                           // æ­»åŒºè¡¥å
             -¿å€¼
                      FOC_TRGDLY = 0x06;                                                                         // ADCé
             -‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€‚
                      // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                      SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
                      FOC_TBLO = PWM_OVERMODULE_TIME;                       // è¿‡è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
                      /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
                      #if (SVPMW_Mode == SVPWM_7_Segment)
                      {
                          ClrBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
                      }
                      #elif (SVPMW_Mode == SVPWM_5_Segment)
                      {
                          SetBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
                      }
                      #endif //end SVPMW_Mode
                      #if (DouRes_Sample_Mode == DouRes_1_Cycle)
                      {
                          ClrBit(FOC_CR2, DSS);                                                           // 7æ®µå¼
                      }
                      #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
                      {
                          SetBit(FOC_CR2, DSS);                                                           // 7æ®µå¼
                      }
                      #endif //end DouRes_Sample_Mode
                  }
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 4   

                  #endif  //end Shunt_Resistor_Mode
 165   1          /* ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ */
 166   1          #if (CalibENDIS == Enable)
 167   1          {
 168   2              if (mcCurOffset.OffsetFlag == 1)
 169   2              {
 170   3                  #if (Shunt_Resistor_Mode == Single_Resistor)          // å•ç”µé˜»æ ¡æ­£
 171   3                  {
 172   4                      /*set ibus current sample offset*/
 173   4                      SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
 174   4                      FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥Ibusçš„åç½®
 175   4                      
 176   4                  }
 177   3                  #elif (Shunt_Resistor_Mode == Double_Resistor)        // åŒç”µé˜»æ ¡æ­£
                          {
                              /*set ia, ib current sample offset*/
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                              FOC_CSO  = mcCurOffset.IuOffset;                  // å†™å…¥IAçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                              FOC_CSO  = mcCurOffset.IvOffset;                 // å†™å…¥IBçš„åç½®
                          
                          }
                          #elif (Shunt_Resistor_Mode == Three_Resistor)         // ä¸‰ç”µé˜»æ ¡æ­£
                          {
                              /*set ibus current sample offset*/
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
                              FOC_CSO = mcCurOffset.IuOffset;                  // å†™å…¥IAçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
                              FOC_CSO = mcCurOffset.IvOffset;                   // å†™å…¥IBçš„åç½®
                          
                              SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
                              FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥ICçš„åç½®
                          }
                          #endif  //end Shunt_Resistor_Mode
 200   3              }
 201   2          }
 202   1          #endif  //end CalibENDIS
 203   1          /*  -------------------------------------------------------------------------------------------------
 204   1              DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 205   1              OCS = 0, DRV_COMR
 206   1              OCS = 1, FOC/SVPWM/SPWM
 207   1              -------------------------------------------------------------------------------------------------*
             -/
 208   1          /*è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC*/
 209   1          SetBit(DRV_CR, OCS);
 210   1          /*DRVè®¡æ•°å™¨ä½¿èƒ½ï¼Œ0-ç¦æ­¢ï¼Œ1-ä½¿èƒ½*/
 211   1          SetBit(DRV_CR, DRVEN);    
 212   1          
 213   1      //    ClrBit(DRV_CR, DRVEN);
 214   1      //    
 215   1      //    /*ä½¿èƒ½FOC*/
 216   1      //    ClrBit(DRV_CR, FOCEN);
 217   1      //    SetBit(DRV_CR, FOCEN);
 218   1      //    SetBit(FOC_CR3, ESCMS);
 219   1      //    /*é…ç½®FOCå¯„å­˜å™¨*/
 220   1      //    FOC_CR1             = 0;                                                                            
             -// æ¸…é›¶ FOC_CR1
 221   1      //    FOC_CR2             = 0;                                                                            
             -// æ¸…é›¶ FOC_CR2
 222   1      //    FOC_IDREF       = 0;                                                                            // æ
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 5   

             -¸…é›¶ Id
 223   1      //    FOC_IQREF       = 0;                                                                            // æ
             -¸…é›¶ Iq
 224   1      //    FOC__THETA      = 0;                                                                            // æ
             -¸…é›¶ è§’åº¦
 225   1      //    FOC_RTHEACC     = 0;                                                                            // æ
             -¸…é›¶ çˆ¬å¡å‡½æ•°çš„åˆå§‹åŠ é€Ÿåº¦
 226   1      //    FOC__RTHESTEP   = 0;                                                                        //
 227   1      //    FOC__RTHECNT    = 0;                                                                            //
 228   1      //    FOC_THECOMP     = _Q15(10.0 / 180.0);                                            // SMO ä¼°ç®—è¡¥å¿
             -è§’
 229   1      //    FOC_THECOR         = 0x04;                                                                 // è¯¯å·®
             -è§’åº¦è¡¥å¿
 230   1      //    /*ç”µæµç¯å‚æ•°é…ç½®*/
 231   1      //    FOC_DMAX            = DOUTMAX;
 232   1      //    FOC_DMIN            = DOUTMIN;
 233   1      //    FOC_QMAX            = QOUTMAX;
 234   1      //    FOC_QMIN            = QOUTMIN;
 235   1      //    /*ä½ç½®ä¼°ç®—å‚æ•°é…ç½®*/
 236   1      //    FOC_EK1             = OBS_K1T;
 237   1      //    FOC_EK2             = OBS_K2T;
 238   1      //    FOC_EK3             = OBS_K3T;
 239   1      //    FOC_EK4             = OBS_K4T;
 240   1      //    FOC_FBASE           = OBS_FBASE;
 241   1      //    FOC_OMEKLPF         = SPEED_KLPF;
 242   1      //    FOC_EBMFK           = OBS_KLPF;
 243   1      //    FOC_TGLI            = PWM_TGLI_LOAD;
 244   1      //  
 245   1      //  #if (EstimateAlgorithm == AO)
 246   1      //    SetBit(FOC_CR3, MFP_EN);
 247   1      //  #else
 248   1      //  ClrBit(FOC_CR3, MFP_EN);
 249   1      //  #endif
 250   1      //  
 251   1      //     /*********PLLæˆ–SMO/AO**********/
 252   1      //    #if (EstimateAlgorithm == PLL)
 253   1      //    {
 254   1      //        SetBit(FOC_CR2, ESEL);
 255   1      //        FOC_KSLIDE      = OBSE_PLLKP_GAIN;
 256   1      //        FOC_EKLPFMIN    = OBSE_PLLKI_GAIN;    
 257   1      //    }
 258   1      //    #else
 259   1      //    {
 260   1      //        ClrBit(FOC_CR2, ESEL);
 261   1      //        FOC_KSLIDE    = OBS_KSLIDE;
 262   1      //        FOC_EKLPFMIN    = OBS_EA_KS;
 263   1      //    }
 264   1      //    #endif //end SVPMW_Mode
 265   1      //    SetBit(FOC_CR1, SVPWMEN);                                                           // SVPWMæ¨¡å¼
 266   1      //    
 267   1      //    //  /*æ­£åè½¬*/
 268   1      //    if (MCCtrl.FR_Status == 1)
 269   1      //    {
 270   1      //        SetBit(DRV_CR, DDIR);                              // åè½¬æ ‡å¿—ä½
 271   1      //    }
 272   1      //    else
 273   1      //    {
 274   1      //        ClrBit(DRV_CR, DDIR);
 275   1      //    }
 276   1      //    
 277   1      //    /**è¿‡è°ƒåˆ¶**/
 278   1      //    #if (OverModulation)
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 6   

 279   1      //    {
 280   1      //        SetBit(FOC_CR1, OVMDL);                                                 // è¿‡è°ƒåˆ¶
 281   1      //    }
 282   1      //    #endif //end OverModulation
 283   1      //    /*å•ç”µé˜»é‡‡æ ·ï¼›éœ€è¦æœ€å°é‡‡æ ·çª—,FOC_TRGDLYä¸º0ï¼Œä¸ƒæ®µå¼SVPWMæ–¹å¼*/
 284   1      //    #if (Shunt_Resistor_Mode == Single_Resistor)
 285   1      //    {
 286   1      //        SetReg(FOC_CR1, CSM0 | CSM1, 0x00);
 287   1      //        FOC_TSMIN = PWM_TS_LOAD;                                                          // æœ€å°é‡‡æ 
             -·çª—å£
 288   1      //        FOC_TRGDLY = 0x15;                                                                // é‡‡æ ·æ—¶åˆ
             -»åœ¨ä¸­ç‚¹ï¼Œä¸€èˆ¬è€ƒè™‘å¼€å…³å™ªå£°å½±å“ï¼Œä¼šè®¾ç½®å»¶è¿Ÿï¼›
 289   1      //        // 0x0cè¡¨ç¤ºå»¶è¿Ÿ12ä¸ªclockï¼Œæå‰ç”¨åç å½¢å¼ï¼Œå¦‚0x84è¡¨ç¤ºæå‰12ä¸ªclockã€‚
 290   1      //        ClrBit(FOC_CR2, F5SEG);                                                           // 7æ®µå¼
 291   1      //        SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
 292   1      //    }
 293   1      //    /*åŒç”µé˜»é‡‡æ ·ï¼Œå¯è®¾ç½®æ­»åŒºè¡¥å¿å€¼ï¼Œåœ¨ä¸‹é™æ²¿ç»“æŸå‰å¼€å§‹é‡‡æ ·Iaï¼Œé…ç½®81*/
 294   1      //    #elif (Shunt_Resistor_Mode == Double_Resistor)                  // double resistor sample
 295   1      //    {
 296   1      //        SetReg(FOC_CR1, CSM0 | CSM1, CSM0);
 297   1      //        FOC_TSMIN = PWM_DT_LOAD;                                                            // æ­»åŒºè¡¥
             -å¿å€¼
 298   1      //        FOC_TRGDLY = 0x83;                                                                    // ADCé‡‡æ
             - ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒ
 299   1      //        // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
 300   1      //        FOC_TBLO = PWM_DLOWL_TIME;                            //ä¸‹æ¡¥è‡‚æœ€å°è„‰å†²ï¼Œä¿è¯é‡‡æ ·
 301   1      //        SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, 0x00);
 302   1      //        /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
 303   1      //        #if (SVPMW_Mode == SVPWM_7_Segment)
 304   1      //        {
 305   1      //            ClrBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
 306   1      //        }
 307   1      //        #elif (SVPMW_Mode == SVPWM_5_Segment)
 308   1      //        {
 309   1      //            SetBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
 310   1      //        }
 311   1      //        #endif
 312   1      //        #if (DouRes_Sample_Mode == DouRes_1_Cycle)
 313   1      //        {
 314   1      //            ClrBit(FOC_CR2, DSS);                                                             // 7æ®µå¼
 315   1      //        }
 316   1      //        #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
 317   1      //        {
 318   1      //            SetBit(FOC_CR2, FOC_DSS);                                                       // 7æ®µå¼
 319   1      //        }
 320   1      //        #endif //end DouRes_Sample_Mode
 321   1      //    }
 322   1      //    /*ä¸‰ç”µé˜»é‡‡æ ·*/
 323   1      //    #elif (Shunt_Resistor_Mode == Three_Resistor)                     // signel resistor sample
 324   1      //    {
 325   1      //        SetReg(FOC_CR1, CSM0 | CSM1, CSM0 | CSM1);// ä¸‰ç”µé˜»
 326   1      //        FOC_TSMIN  = PWM_DT_LOAD;                                                           // æ­»åŒºè¡¥
             -å¿å€¼
 327   1      //        FOC_TRGDLY = 06;                                                                          // ADC
             -é‡‡æ ·çš„æ—¶åˆ»ï¼Œé‡‡æ ·æ—¶åˆ»åœ¨è®¡æ•°å™¨é›¶ç‚¹é™„è¿‘ï¼Œ83ä¸ºä¸‹é™æ²¿ç»“æŸå‰3ä¸ªclocké‡‡æ ·Iaï¼Œä¸å•ç”µé˜»ä¸åŒã€
             -‚
 328   1      //        // 01ä¸ºä¸Šå‡æ²¿å¼€å§‹åç¬¬ä¸€ä¸ªclockå¼€å§‹é‡‡æ ·ã€‚æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
 329   1      //        SetReg(CMP_CR1, CMP3MOD0 | CMP3MOD1, CMP3MOD0 | CMP3MOD1);
 330   1      //        FOC_TBLO = PWM_OVERMODULE_TIME;                       // è¿‡è°ƒåˆ¶ç”µæµé‡‡æ ·å¤„ç†çš„TBè„‰å®½
 331   1      //        /*äº”æ®µå¼æˆ–ä¸ƒæ®µå¼é€‰æ‹©*/
 332   1      //        #if (SVPMW_Mode == SVPWM_7_Segment)
 333   1      //        {
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 7   

 334   1      //            ClrBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
 335   1      //        }
 336   1      //        #elif (SVPMW_Mode == SVPWM_5_Segment)
 337   1      //        {
 338   1      //            SetBit(FOC_CR2, F5SEG);                                                         // 7æ®µå¼
 339   1      //        }
 340   1      //        #endif //end SVPMW_Mode
 341   1      //        #if (DouRes_Sample_Mode == DouRes_1_Cycle)
 342   1      //        {
 343   1      //            ClrBit(FOC_CR2, DSS);                                                           // 7æ®µå¼
 344   1      //        }
 345   1      //        #elif (DouRes_Sample_Mode == DouRes_2_Cycle)
 346   1      //        {
 347   1      //            SetBit(FOC_CR2, DSS);                                                           // 7æ®µå¼
 348   1      //        }
 349   1      //        #endif //end DouRes_Sample_Mode
 350   1      //    }
 351   1      //    #endif  //end Shunt_Resistor_Mode
 352   1      //    /* ä½¿èƒ½ç”µæµåŸºå‡†æ ¡æ­£ */
 353   1      //    #if (CalibENDIS == Enable)
 354   1      //    {
 355   1      //        if (mcCurOffset.OffsetFlag == 1)
 356   1      //        {
 357   1      //            #if (Shunt_Resistor_Mode == Single_Resistor)          // å•ç”µé˜»æ ¡æ­£
 358   1      //            {
 359   1      //                /*set ibus current sample offset*/
 360   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
 361   1      //                FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥Ibusçš„åç½®
 362   1      //                
 363   1      //            }
 364   1      //            #elif (Shunt_Resistor_Mode == Double_Resistor)          // åŒç”µé˜»æ ¡æ­£
 365   1      //            {
 366   1      //                /*set ia, ib current sample offset*/
 367   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
 368   1      //                FOC_CSO  = mcCurOffset.IuOffset;                  // å†™å…¥IAçš„åç½®
 369   1      //            
 370   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
 371   1      //                FOC_CSO  = mcCurOffset.IvOffset;                    // å†™å…¥IBçš„åç½®
 372   1      //            
 373   1      //            }
 374   1      //            #elif (Shunt_Resistor_Mode == Three_Resistor)         // ä¸‰ç”µé˜»æ ¡æ­£
 375   1      //            {
 376   1      //                /*set ibus current sample offset*/
 377   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC0);
 378   1      //                FOC_CSO = mcCurOffset.IuOffset;                 // å†™å…¥IAçš„åç½®
 379   1      //            
 380   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, CSOC1);
 381   1      //                FOC_CSO = mcCurOffset.IvOffset;                   // å†™å…¥IBçš„åç½®
 382   1      //            
 383   1      //                SetReg(FOC_CR2, CSOC0 | CSOC1, 0x00);
 384   1      //                FOC_CSO = mcCurOffset.Iw_busOffset;               // å†™å…¥ICçš„åç½®
 385   1      //            }
 386   1      //            #endif  //end Shunt_Resistor_Mode
 387   1      //        }
 388   1      //    }
 389   1      //    #endif  //end CalibENDIS
 390   1      //    /*  ------------------------------------------------------------------------------------------------
             --
 391   1      //        DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 392   1      //        OCS = 0, DRV_COMR
 393   1      //        OCS = 1, FOC/SVPWM/SPWM
 394   1      //        ------------------------------------------------------------------------------------------------
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 8   

             --*/
 395   1      //    /*è®¡æ•°å™¨æ¯”è¾ƒå€¼æ¥æºFOC*/
 396   1      //    SetBit(DRV_CR, OCS);
 397   1      //    
 398   1      //    SetBit(DRV_CR, DRVEN);
 399   1      }
 400          
 401          /** 
 402           * @brief     é¢„å……ç”µåˆ†ä¸‰æ­¥ï¼Œç¬¬ä¸€æ­¥æ˜¯å¯¹Uç›¸è¿›è¡Œé¢„å……ç”µï¼Œç¬¬äºŒæ­¥æ˜¯å¯¹Vä¸¤ç›¸è¿›è¡Œé¢„å……
             -ç”µ;ç¬¬ä¸‰æ­¥æ˜¯å¯¹Wä¸‰ç›¸è¿›è¡Œé¢„å……ç”µã€‚
 403           * @brief     ä½å‹åº”ç”¨ä¸€èˆ¬ä¸éœ€è¦é¢„å……ç”µï¼Œåœ¨customer.hç¦æ­¢é¢„å……ç”µåŠŸèƒ½å¯„å³å¯
 404           * @exception åœ¨ä½åŠŸç‡é«˜å‹åº”ç”¨ä¸­ï¼Œè¿‡æµå€¼è¾ƒå°ï¼Œå……ç”µç”µæµè¿‡å¤§å¯èƒ½å¯¼è‡´è§¦å‘ç¡¬ä»¶è¿
             -‡æµ, éœ€è¦æ³¨æ„æ£€æŸ¥
 405           * @date      2022-07-14
 406           */
 407          void Motor_Charge(void)
 408          {
 409   1          if (McStaSet.SetFlag.ChargeSetFlag == 0)
 410   1          {
 411   2              McStaSet.SetFlag.ChargeSetFlag = 1;
 412   2          
 413   2          /*é©±åŠ¨æœ‰æ•ˆç”µå¹³å’Œç©ºé—²ç”µå¹³*/
 414   2          #if (PWM_Level_Mode == High_Level)
 415   2          {
 416   3            DRV_CMR &= 0x003f;
 417   3            DRV_OUT &= 0xC0;
 418   3          }
 419   2          #elif (PWM_Level_Mode == Low_Level)
                  {
                          SetBit(P1_OE, P10);
                          GP10 = 1;     
                    DRV_CMR |= 0x0fc0;
                    DRV_OUT = 0x3F;
                  }
                  #elif (PWM_Level_Mode == UP_H_DOWN_L)
                  {
                    DRV_CMR = 0x0540;
                    DRV_OUT = 0x2A;
                  }
                  #elif (PWM_Level_Mode == UP_L_DOWN_H)
                  {
                    DRV_CMR &= 0x0a80;
                    DRV_OUT = 0x15;
                  }
                  #endif //end PWM_Level_Mode   
 437   2          
 438   2              #if (IPMState == IPMtest)
                      {
                          DRV_DR = 0.7 * DRV_ARR;                          // IPM 70% duty
                      }
                      #elif (IPMState == NormalRun)            // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 443   2              {
 444   3                  DRV_DR = 0.7 * DRV_ARR;                      //ä¸‹æ¡¥è‡‚10% duty
 445   3              }
 446   2              #endif
 447   2              /*  ----------------------------------------------------------------------------------------------
             ----
 448   2                  DRV_CTLï¼šPWMæ¥æºé€‰æ‹©
 449   2                  OCS = 0, DRV_COMR
 450   2                  OCS = 1, FOC/SVPWM/SPWM
 451   2                  ----------------------------------------------------------------------------------------------
             ----*/
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 9   

 452   2              ClrBit(DRV_CR, OCS);
 453   2              mcFocCtrl.ChargeStep = 0;
 454   2          }
 455   1          
 456   1          if ((mcFocCtrl.State_Count < Charge_Time) && (mcFocCtrl.ChargeStep == 0))
 457   1          {
 458   2              mcFocCtrl.ChargeStep = 1;
 459   2              #if (IPMState == IPMtest)
                      {
                          DRV_CMR |= 0x03;                         // Uç›¸è¾“å‡º
                      }
                      #elif (IPMState == NormalRun)                // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 464   2              {
 465   3                  DRV_CMR |= 0x01;                         // Uç›¸ä¸‹æ¡¥è‡‚é€š
 466   3              }
 467   2              #endif
 468   2              MOE = 1;
 469   2          }
 470   1          
 471   1          if (( mcFocCtrl.State_Count <= (Charge_Time << 1) / 3) && (mcFocCtrl.ChargeStep == 1))
 472   1          {
 473   2              mcFocCtrl.ChargeStep = 2;
 474   2              #if (IPMState == IPMtest)
                      {
                          DRV_CMR |= 0x0F;                         // Uã€Vç›¸è¾“å‡º
                      }
                      #elif (IPMState == NormalRun)                // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 479   2              {
 480   3                  DRV_CMR |= 0x04;                         // Vç›¸ä¸‹æ¡¥è‡‚å¯¼é€š
 481   3              }
 482   2              #endif
 483   2          }
 484   1          
 485   1          if ((mcFocCtrl.State_Count <= Charge_Time / 3) && (mcFocCtrl.ChargeStep == 2))
 486   1          {
 487   2              mcFocCtrl.ChargeStep = 3;
 488   2              #if (IPMState == IPMtest)
                      {
                          DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
                      }
                      #elif (IPMState == NormalRun)                // æ­£å¸¸æŒ‰ç”µæœºçŠ¶æ€æœºè¿è¡Œ
 493   2              {
 494   3                  DRV_CMR |= 0x10;                         // Wç›¸ä¸‹æ¡¥è‡‚å¯¼é€š
 495   3              }
 496   2              #endif
 497   2          }
 498   1      }
 499          /*---------------------------------------------------------------------------*/
 500          /*  Name     :   void Motor_Align(void)
 501          /* Input    :   NO
 502          /* Output   :   NO
 503          /* Description: é¢„å®šä½å‡½æ•°ï¼Œå½“æ— é€†é£åˆ¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½å›ºå®šåˆå§‹ä½ç½®;å½“æœ‰é€†é£åˆ
             -¤æ–­æ—¶ï¼Œé‡‡ç”¨é¢„å®šä½åˆ¹è½¦
 504          /*---------------------------------------------------------------------------*/
 505          void Motor_Align(void)
 506          {
 507   1          if (McStaSet.SetFlag.AlignSetFlag == 0)
 508   1          {
 509   2              McStaSet.SetFlag.AlignSetFlag = 1;
 510   2              /*FOCåˆå§‹åŒ–*/
 511   2              FOC_Init();
 512   2              SetBit(FOC_CR2, UQD);
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 10  

 513   2            
 514   2              /*é…ç½®é¢„å®šä½çš„ç”µæµã€KPã€KI*/
 515   2              FOC_IDREF = ID_Align_CURRENT;
 516   2              FOC_IQREF = IQ_Align_CURRENT;
 517   2              FOC_DQKP  = DQKP_Alignment;
 518   2              FOC_DQKI  = DQKI_Alignment;
 519   2              FOC_EKP     = OBSW_KP_GAIN;
 520   2              FOC_EKI     = OBSW_KI_GAIN;
 521   2            
 522   2              /*é…ç½®é¢„å®šä½è§’åº¦*/
 523   2              #if (AlignTestMode==1)
                      {
                          FOC__THETA      = Align_Theta;
                      }
                      #else
 528   2              {
 529   3                  #if (PosCheckEnable==1)
                          {
                              FOC__THETA    = mcFocCtrl.mcPosCheckAngle;
                          }
                          #else
 534   3                  {
 535   4                      FOC__THETA      = Align_Theta;
 536   4                  }
 537   3                  #endif    //end PosCheckEnable
 538   3              }
 539   2              #endif  //end AlignTestMode
 540   2              
 541   2              /*********PLLæˆ–SMO/AO**********/
 542   2              #if (EstimateAlgorithm == PLL)
                      {
                          FOC__ETHETA   = FOC__THETA;
                      }
                      #else
 547   2              {
 548   3                FOC__ETHETA   = FOC__THETA - 4096;
 549   3              }
 550   2              #endif //end    EstimateAlgorithm
 551   2          
 552   2              /*ä½¿èƒ½è¾“å‡º*/
 553   2              DRV_CMR |= 0x3F;                         // Uã€Vã€Wç›¸è¾“å‡º
 554   2              MOE = 1;
 555   2          }
 556   1      }
 557          
 558          /** 
 559           * @brief     é™æ­¢å¯åŠ¨é…ç½®å‡½æ•°
 560           * @date      2022-07-14
 561           */
 562          void Motor_Open(void)
 563          {   
 564   1          if (McStaSet.SetFlag.StartSetFlag == 0)
 565   1          {
 566   2              McStaSet.SetFlag.StartSetFlag = 1;
 567   2            
 568   2              FOC_Init();
 569   2              /****å¯åŠ¨åˆå§‹è§’åº¦èµ‹å€¼**/
 570   2              #if (PosCheckEnable)
                      {
                          FOC__THETA  = mcFocCtrl.mcPosCheckAngle;// æœ‰åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨åˆå§‹ä½ç½®è§’
                      }
                      #else
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 11  

 575   2              {
 576   3                  FOC__THETA      = Align_Theta;            // æ— åˆå§‹ä½ç½®æ£€æµ‹ï¼Œåˆ™ç”¨é¢„å®šä½è§’
 577   3              }
 578   2              #endif
 579   2              /*********PLLæˆ–SMO/AO**********/
 580   2              #if (EstimateAlgorithm == PLL)
                      {
                          FOC__ETHETA   = FOC__THETA;
                      }
                      #else
 585   2              {
 586   3                FOC__ETHETA   = FOC__THETA - 4096;
 587   3              }
 588   2              #endif //end    EstimateAlgorithm
 589   2              
 590   2              /*å¯åŠ¨ç”µæµã€KPã€KIã€FOC_EKPã€FOC_EKI*/
 591   2              FOC_IDREF = ID_Start_CURRENT;                               // Dè½´å¯åŠ¨ç”µæµ
 592   2              mcFocCtrl.mcIqref = IQ_Start_CURRENT;                       // Qè½´å¯åŠ¨ç”µæµ
 593   2              #if ((FRDetectMethod==BEMFMethod)&&(TailWind_Mode == TailWind))
                      {
                          if (BEMFDetect.BEMFCCWFlag == 1)
                          {
                              mcFocCtrl.mcIqref += I_Value(0.95);                  //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                          }
                          else if (BEMFDetect.BEMFCCWFlag == 2)
                          {
                              mcFocCtrl.mcIqref += I_Value(0.8);                  //é€†é£æ—¶ï¼ŒåŠ å¤§å¯åŠ¨ç”µæµ
                          }
                      }
                      #endif
 605   2              FOC_DQKP = DQKPStart;
 606   2              FOC_DQKI = DQKIStart;
 607   2              
 608   2              //å¯åŠ¨æ—¶è®¾ç½®Qè½´PIä¸‹é™èµ·å§‹å€¼
 609   2              FOC_QMAX          = QOUTMAX;
 610   2              FOC_QMIN          = QOUTMINST;
 611   2              FOC_EKP     = OBSW_KP_GAIN;
 612   2              FOC_EKI     = OBSW_KI_GAIN;
 613   2              
 614   2              /*å¯åŠ¨æ–¹å¼é€‰æ‹©*/
 615   2              #if (START_MODE == Omega_Start)                  // Omega å¯åŠ¨
 616   2              {
 617   3                  FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
 618   3                  FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
 619   3                  FOC_EFREQHOLD = Motor_Omega_Ramp_End;
 620   3                  SetBit(FOC_CR1, EFAE);                                                          // ä¼°ç®—å™¨å¼
             -ºåˆ¶è¾“å‡º
 621   3                  ClrBit(FOC_CR1, RFAE);                                                          // ç¦æ­¢å¼ºæ‹
             -‰
 622   3                  SetBit(FOC_CR1, ANGM);                                                          // ä¼°ç®—æ¨¡å¼
             -
 623   3              }
 624   2              #elif (START_MODE == Open_Omega_Start)
                      {
                          FOC_RTHEACC     = Motor_Open_Ramp_ACC;                                    // çˆ¬å¡å‡½æ•°çš„åˆ
             -å§‹åŠ é€Ÿåº¦
                          FOC__RTHESTEP   = Motor_Open_Ramp_Min;                              // 0.62 degree acce speed
                          FOC__RTHECNT    = MOTOR_OPEN_ACC_CNT;                                   // acce time
                          FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
                          FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
                          FOC_EFREQHOLD = Motor_Omega_Ramp_End;
                          SetBit(FOC_CR1, EFAE);                                                          // ä¼°ç®—å™¨å¼
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 12  

             -ºåˆ¶è¾“å‡º
                          SetBit(FOC_CR1, RFAE);                                                          // ç¦æ­¢å¼ºæ‹
             -‰
                          SetBit(FOC_CR1, ANGM);                                                          // ä¼°ç®—æ¨¡å¼
             -
                      }
                  #elif (START_MODE == Observer_Start)
                      {
                          FOC_EFREQACC    = Motor_Omega_Ramp_ACC;
                          FOC_EFREQMIN    = Motor_Omega_Ramp_Min;
                          FOC_EFREQHOLD = Motor_Omega_Ramp_End;
                          SetBit(FOC_CR1, EFAE);                                                          // ä¼°ç®—å™¨å¼
             -ºåˆ¶è¾“å‡º
                          ClrBit(FOC_CR1, RFAE);                                                          // ç¦æ­¢å¼ºæ‹
             -‰
                          SetBit(FOC_CR1, ANGM);                                                          // ä¼°ç®—æ¨¡å¼
             -
                      }
                      #endif //end Open_Start_Mode
 646   2          }
 647   1          
 648   1          /*ä¸åŒå¯åŠ¨æ–¹å¼ä¸‹ï¼Œåˆ‡æ¢åˆ°MCRUNçŠ¶æ€*/
 649   1          #if (START_MODE == Open_Omega_Start)
                  {
                      mcFocCtrl.State_Count = 120;
                      FOC_EKP = OBSW_KP_GAIN_RUN;                            // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                      FOC_EKI   = OBSW_KI_GAIN_RUN;                                  // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                  }
                  #elif (START_MODE == Omega_Start)
 656   1          {
 657   2              /*********PLLæˆ–SMO/AO**********/
 658   2              #if (EstimateAlgorithm == PLL)
                      {
                          FOC_EKP = OBSW_KP_GAIN_RUN2;                            // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                          FOC_EKI   = OBSW_KI_GAIN_RUN2;                                  // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                      }
                      #else
 664   2              {
 665   3                mcFocCtrl.State_Count = 100;
 666   3              }
 667   2              #endif //end    EstimateAlgorithm      
 668   2          }
 669   1        #elif (START_MODE == Observer_Start)
                  {
                      /*********PLLæˆ–SMO/AO**********/
                      #if (EstimateAlgorithm == PLL)
                      {
                          FOC_EKP = OBSW_KP_GAIN_RUN2;                            // ä¼°ç®—å™¨é‡Œçš„PIçš„KP
                          FOC_EKI   = OBSW_KI_GAIN_RUN2;                                  // ä¼°ç®—å™¨é‡Œçš„PIçš„KI
                      }
                  #else
                  {
                    mcFocCtrl.State_Count = 120;
                  }
                      #endif //end    EstimateAlgorithm  
                      LowSpeedObserverInit();   
                  }
                  #endif //end Open_Start_Mode
 685   1          FOC_IQREF = mcFocCtrl.mcIqref;                          // Qè½´å¯åŠ¨ç”µæµ
 686   1      }
 687          
 688          /** 
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 13  

 689           * @brief     é¡ºé€†é£æ£€æµ‹é…ç½®å‡½æ•°ï¼Œé¡ºé€†é£å¤„ç†
 690           * @date      2022-07-14
 691           */
 692          void Motor_TailWind(void)
 693          {
 694   1          #if (TailWind_Mode == NoTailWind)     // æ— é¡ºé€†é£å¤„ç†çš„ï¼Œç›´æ¥è·³å…¥ä¸‹ä¸€ä¸ªçŠ¶æ€
 695   1          {
 696   2              mcState                           = mcPosiCheck;
 697   2              McStaSet.SetFlag.PosiCheckSetFlag = 0;
 698   2              mcFocCtrl.mcPosCheckAngle         = 0xffff;         // è§’åº¦èµ‹åˆå€¼
 699   2          }
 700   1          #elif (TailWind_Mode == TailWind)
                  {
                      if (mcFocCtrl.State_Count == 0)
                      {
                          if (McStaSet.SetFlag.TailWindSetFlag  == 0) //åˆå§‹åŒ–
                          {
                              McStaSet.SetFlag.TailWindSetFlag = 1;
                              #if (FRDetectMethod==BEMFMethod)
                              {
                                  BEMFDetectInit();
                              }
                              #elif (FRDetectMethod==FOCMethod)
                              {
                                  TailWindDetectInit();
                              }
                              #endif
                          }
                  
                          #if (FRDetectMethod==BEMFMethod)
                          {
                              BEMFDealwith();
                          }
                          #elif (FRDetectMethod==FOCMethod)
                          {
                              FOCTailWindDealwith();
                          }
                          #endif
                      }
                  }
                  #endif
 730   1      }
 731          
 732          /** 
 733           * @brief     æ§åˆ¶å…³æœºå’Œåˆ¹è½¦
 734           * @date      2022-07-14
 735           */
 736          void MC_Stop(void)
 737          {
 738   1          if ((mcFocCtrl.SpeedFlt < Motor_Stop_Speed) || (mcFocCtrl.State_Count == 0)) // å®é™…è½¬é€Ÿä½äºMoto
             -r_Min_Speedæˆ–å»¶æ—¶åˆ°äº†ï¼Œå…³é—­PWMè¾“å‡ºæˆ–è¿›å…¥åˆ¹è½¦
 739   1          {
 740   2              #if (StopBrakeFlag == 0)
                      {
                          FOC_CR1 = 0x00;
                          /*å…³é—­FOC*/
                          ClrBit(DRV_CR, FOCEN);
                          MOE = 0;
                          mcState = mcBrake;
                      }
                      #else
 749   2              {
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 14  

 750   3                  if ((mcFocCtrl.SpeedFlt < Motor_Stop_Speed) && (mcFocCtrl.SpeedFlt > Motor_Min_Speed))        
             -                                            // ä½äºStopSpeed,åˆ¹è½¦
 751   3                  {
 752   4                      FOC_IQREF             = I_Value(-0.2);
 753   4                  }
 754   3                  else if (mcFocCtrl.SpeedFlt < Motor_Min_Speed)
 755   3                  {
 756   4                      MOE = 0;
 757   4                      FOC_CR1 = 0x00;
 758   4                      ClrBit(DRV_CR, FOCEN);
 759   4                      DRV_DR  = DRV_ARR + 1;
 760   4                      DRV_CMR &= 0xFFC0;
 761   4                      DRV_CMR |= 0x015;                                                                         
             -          // ä¸‰ç›¸ä¸‹æ¡¥è‡‚é€šï¼Œåˆ¹è½¦
 762   4                      ClrBit(DRV_CR, OCS);                                                                      
             -          // OCS = 0, DRV_COMR;OCS = 1, FOC/SVPWM/SPWM
 763   4                      MOE = 1;
 764   4                      mcState               = mcBrake;
 765   4                      mcFocCtrl.State_Count = StopWaitTime;
 766   4                  }
 767   3                  else
 768   3                  {
 769   4                      FOC_IQREF             = 0;
 770   4                  }
 771   3              }
 772   2              #endif
 773   2          }
 774   1          else if (MCCtrl.FlagONOFF  > 0)                                                                       
             -    // StopçŠ¶æ€æ—¶ï¼Œç”µæœºåœ¨å‡é€ŸçŠ¶æ€ï¼Œåˆå¼€æœºè¿›å…¥æ­£å¸¸è¿è¡Œæ¨¡å¼
 775   1          {
 776   2              mcState            = mcRun;
 777   2              mcFocCtrl.CtrlMode = 0;
 778   2              FOC_IQREF          = IQ_RUN_CURRENT;
 779   2          }
 780   1      }
 781          
 782          /** 
 783           * @brief     æ§åˆ¶å˜é‡ä¸Šç”µåˆå§‹åŒ–,åŒ…æ‹¬ä¿æŠ¤å‚æ•°çš„åˆå§‹åŒ–ã€ç”µæœºçŠ¶æ€åˆå§‹åŒ–
 784           * @brief     ä¸Šç”µåªè¿è¡Œä¸€æ¬¡
 785           * @date      2022-07-14
 786           */
 787          void MotorcontrolInit(void)
 788          {
 789   1          memset(&mcLedDisplay,0, sizeof(mcLedDisplay));
 790   1          
 791   1          /***********ä¿æŠ¤******************/
 792   1          memset(&mcFaultDect, 0, sizeof(FaultVarible));                                                        
             -  // FaultVaribleå˜é‡æ¸…é›¶
 793   1        
 794   1          /******ä¿æŠ¤æ¬¡æ•°*********/
 795   1          memset(&mcProtectTime, 0, sizeof(ProtectVarible));                                                    
             -  // ProtectVaribleä¿æŠ¤æ¬¡æ•°æ¸…é›¶
 796   1      
 797   1          /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 798   1          McStaSet.SetMode                   = 0;
 799   1        
 800   1          /*****å¤–éƒ¨æ§åˆ¶ç¯*******/
 801   1          memset(&mcFocCtrl, 0, sizeof(FOCCTRL));                     // mcFocCtrlå˜é‡æ¸…é›¶
 802   1      
 803   1          mcCurOffset.IuOffsetSum            = 16383;
 804   1          mcCurOffset.IvOffsetSum            = 16383;
 805   1          mcCurOffset.Iw_busOffsetSum        = 16383;
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 15  

 806   1        
 807   1          Rom.FlagFlashWrite = 0;                                   //Flashå†™å…¥
 808   1      }
 809          
 810          /** 
 811           * @brief     åˆå§‹åŒ–ç”µæœºå‚æ•°ï¼Œæ¯æ¬¡ç”µæœºé‡å¯å‡ä¼šè¢«è°ƒç”¨
 812           * @warning   éœ€è¦æ³¨æ„å¡«å†™çš„å˜é‡æ˜¯å¦å¯ä»¥åœ¨æ­¤æ—¶åˆ»è¢«åˆå§‹åŒ–
 813           * @date      2022-07-14
 814           */
 815          void VariablesPreInit(void)
 816          {
 817   1          /***********ä¿æŠ¤******************/
 818   1          mcFaultSource = 0;
 819   1          memset(&mcFaultDect, 0, sizeof(FaultVarible));                                                        
             -          // FaultVaribleå˜é‡æ¸…é›¶
 820   1        
 821   1          /*****é¡ºé€†é£åˆ¤æ–­*******/
 822   1          #if (TailWind_Mode==TailWind)
                  #if(FRDetectMethod==BEMFMethod)
                  {
                  }
                  #elif (FRDetectMethod==FOCMethod)
                  {
                      memset(&TailWindDetect, 0, sizeof(MotorTailWindTypeDef));                                     //  
             -TailWindDetectæ‰€æœ‰å˜é‡æ¸…é›¶
                  }
                  #endif  
                  #endif
 832   1        
 833   1          /*****ç”µæœºçŠ¶æ€æœºæ—¶åºå˜é‡***********/
 834   1          McStaSet.SetMode                   = 0;
 835   1        
 836   1          memset(&mcFocCtrl, 0, sizeof(FOCCTRL));                     // mcFocCtrlå˜é‡æ¸…é›¶
 837   1        
 838   1          memset(&LowSpeedObserver, 0, sizeof(MCLowSpeedObserver));
 839   1          
 840   1          memset(&mcLedDisplay,0, sizeof(mcLedDisplay));
 841   1          
 842   1      //    MCCtrl.PowerLimitValue = POWERLPFLIMIT;
 843   1      }
 844          
 845          /** 
 846           * @brief     ä¸Šç”µæ—¶ï¼Œå…ˆå¯¹ç¡¬ä»¶ç”µè·¯çš„ç”µæµè¿›è¡Œé‡‡é›†ï¼Œå†™å…¥å¯¹åº”çš„æ ¡å‡†å¯„å­˜å™¨ä¸­ã€‚
 847                        è°ƒè¯•æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffsetç»“æ„ä½“ä¸­å¯¹åº”å˜é‡æ˜¯å¦åœ¨èŒƒå›´å†…ã€‚é‡‡é›†ç»“æŸå
             -ï¼ŒOffsetFlagç½®1ã€‚
 848           * @date      2022-07-14
 849           */
 850          void GetCurrentOffset(void)
 851          {
 852   1          if (mcCurOffset.OffsetFlag == 0)
 853   1          {
 854   2              SetBit(ADC_CR, ADCBSY);                                  // ä½¿èƒ½ADC
 855   2              
 856   2              while (ReadBit(ADC_CR, ADCBSY));
 857   2              
 858   2              #if (Shunt_Resistor_Mode == Single_Resistor)                   // 29.2ms å•ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µé
             -ªŒè¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IbusOffsetæ˜¯å¦ä¸º4096
 859   2              {
 860   3                  mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x0fff) << 3);
 861   3                  mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
 862   3                  mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
 863   3              }
C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 16  

 864   2              #elif (Shunt_Resistor_Mode == Double_Resistor)                 //44ms åŒç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒè
             -¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetæ˜¯å¦ä¸º4096
                      {
                          mcCurOffset.IuOffsetSum += ((ADC0_DR & 0x0fff) << 3);
                          mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                          mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
                          mcCurOffset.IvOffsetSum += ((ADC1_DR & 0x0fff) << 3);
                          mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                          mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
                          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x0fff) << 3);
                          mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
                          mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                      }
                      #elif (Shunt_Resistor_Mode == Three_Resistor)                 //58.2ms ä¸‰ç”µé˜»æ¨¡å¼ï¼Œä¸Šç”µéªŒ
             -è¯ç¡¬ä»¶ç”µè·¯æ—¶ï¼Œéœ€è§‚å¯ŸmcCurOffset.IaOffsetã€mcCurOffset.IbOffsetã€mcCurOffset.IcOffsetæ˜¯å¦ä¸º4096
                      {
                          mcCurOffset.IuOffsetSum += ((ADC0_DR & 0x0fff) << 3);
                          mcCurOffset.IuOffset = mcCurOffset.IuOffsetSum >> 4;
                          mcCurOffset.IuOffsetSum -= mcCurOffset.IuOffset;
                          mcCurOffset.IvOffsetSum += ((ADC1_DR & 0x0fff) << 3);
                          mcCurOffset.IvOffset = mcCurOffset.IvOffsetSum >> 4;
                          mcCurOffset.IvOffsetSum -= mcCurOffset.IvOffset;
                          mcCurOffset.Iw_busOffsetSum += ((ADC4_DR & 0x0fff) << 3);
                          mcCurOffset.Iw_busOffset = mcCurOffset.Iw_busOffsetSum >> 4;
                          mcCurOffset.Iw_busOffsetSum -= mcCurOffset.Iw_busOffset;
                      }
                      #endif
 889   2              mcCurOffset.OffsetCount++;
 890   2              
 891   2              if (mcCurOffset.OffsetCount > Calib_Time)
 892   2              {
 893   3                  mcCurOffset.OffsetFlag = 1;
 894   3              }
 895   2          }
 896   1      }
 897          
 898          /** 
 899           * @brief     å…³é—­è¾“å‡ºï¼Œå…³é—­FOCï¼Œç”µæœºåˆ‡æ¢åˆ°mcReadyçŠ¶æ€è¢«è°ƒç”¨ä¸€æ¬¡
 900           * @date      2022-07-14
 901           */
 902          void Motor_Ready(void)
 903          {
 904   1          if (McStaSet.SetFlag.CalibFlag == 0)
 905   1          {
 906   2              McStaSet.SetFlag.CalibFlag = 1;
 907   2              ClrBit(DRV_CR, FOCEN);            // å…³é—­FOC
 908   2              MOE            = 0;               // å…³é—­MOE        
 909   2          }
 910   1      }
 911          
 912          /** 
 913           * @brief     ç”µæœºåˆå§‹åŒ–ï¼Œå¯¹ç”µæœºç›¸å…³å˜é‡ã€PIè¿›è¡Œåˆå§‹åŒ–è®¾ç½®,å…³é—­FOCæ‰€éœ€è¦ä½¿ç”¨åˆ
             -°çš„ADC
 914           * @note      å…³é—­FOCæ‰€éœ€è¦ä½¿ç”¨åˆ°çš„ADCï¼ŒFOCæ¨¡å—ä¼šè‡ªåŠ¨è°ƒç”¨ç›¸åº”ADC æ— éœ€å¤–éƒ¨ä½¿èƒ½
 915           * @date      2022-07-14
 916           */
 917          void Motor_Init(void)
 918          {
 919   1          VariablesPreInit();                           // ç”µæœºç›¸å…³å˜é‡åˆå§‹åŒ–
 920   1          PI_Init();                                        // PIåˆå§‹åŒ–
 921   1      }

C51 COMPILER V9.60.7.0   MOTORCONTROLFUNCTION                                              08/30/2023 13:47:05 PAGE 17  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1381    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     21    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
